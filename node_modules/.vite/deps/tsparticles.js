import {
  loadSlim
} from "./chunk-ALFHD7OK.js";
import {
  AlterType,
  AnimatableColor,
  AnimationStatus,
  DestroyType,
  ExternalInteractorBase,
  OptionsColor,
  PixelMode,
  RotateDirection,
  ValueWithRandom,
  Vector,
  arrayRandomIndex,
  calcPositionOrRandomFromSize,
  calcPositionOrRandomFromSizeRanged,
  deepExtend,
  degToRad,
  double,
  executeOnSingleOrMultiple,
  getDistance,
  getDistances,
  getRandom,
  getRangeValue,
  getSize,
  getStyleFromHsl,
  getStyleFromRgb,
  half,
  isArray,
  isInArray,
  isNull,
  isNumber,
  isPointInside,
  itemFromArray,
  itemFromSingleOrMultiple,
  loadFont,
  loadParticlesOptions,
  millisecondsToSeconds,
  originPoint,
  percentDenominator,
  randomInRange,
  rangeColorToHsl,
  rangeColorToRgb,
  setRangeValue,
  updateAnimation
} from "./chunk-O63SVF5O.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@tsparticles/plugin-absorbers/browser/Options/Classes/AbsorberSizeLimit.js
var AbsorberSizeLimit = class {
  constructor() {
    this.radius = 0;
    this.mass = 0;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.mass !== void 0) {
      this.mass = data.mass;
    }
    if (data.radius !== void 0) {
      this.radius = data.radius;
    }
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/Options/Classes/AbsorberSize.js
var AbsorberSize = class extends ValueWithRandom {
  constructor() {
    super();
    this.density = 5;
    this.value = 50;
    this.limit = new AbsorberSizeLimit();
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    super.load(data);
    if (data.density !== void 0) {
      this.density = data.density;
    }
    if (isNumber(data.limit)) {
      this.limit.radius = data.limit;
    } else {
      this.limit.load(data.limit);
    }
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/Options/Classes/Absorber.js
var Absorber = class {
  constructor() {
    this.color = new OptionsColor();
    this.color.value = "#000000";
    this.draggable = false;
    this.opacity = 1;
    this.destroy = true;
    this.orbits = false;
    this.size = new AbsorberSize();
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.color !== void 0) {
      this.color = OptionsColor.create(this.color, data.color);
    }
    if (data.draggable !== void 0) {
      this.draggable = data.draggable;
    }
    this.name = data.name;
    if (data.opacity !== void 0) {
      this.opacity = data.opacity;
    }
    if (data.position !== void 0) {
      this.position = {};
      if (data.position.x !== void 0) {
        this.position.x = setRangeValue(data.position.x);
      }
      if (data.position.y !== void 0) {
        this.position.y = setRangeValue(data.position.y);
      }
    }
    if (data.size !== void 0) {
      this.size.load(data.size);
    }
    if (data.destroy !== void 0) {
      this.destroy = data.destroy;
    }
    if (data.orbits !== void 0) {
      this.orbits = data.orbits;
    }
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/Enums/AbsorberClickMode.js
var AbsorberClickMode;
(function(AbsorberClickMode2) {
  AbsorberClickMode2["absorber"] = "absorber";
})(AbsorberClickMode || (AbsorberClickMode = {}));

// node_modules/@tsparticles/plugin-absorbers/browser/AbsorberInstance.js
var squareExp = 2;
var absorbFactor = 0.033;
var minOrbitLength = 0;
var minRadius = 0;
var minMass = 0;
var minAngle = 0;
var double2 = 2;
var maxAngle = Math.PI * double2;
var minVelocity = 0;
var AbsorberInstance = class {
  constructor(absorbers, container, engine, options, position) {
    this._calcPosition = () => {
      const exactPosition = calcPositionOrRandomFromSizeRanged({
        size: this._container.canvas.size,
        position: this.options.position
      });
      return Vector.create(exactPosition.x, exactPosition.y);
    };
    this._updateParticlePosition = (particle, v) => {
      if (particle.destroyed) {
        return;
      }
      const container2 = this._container, canvasSize = container2.canvas.size;
      if (particle.needsNewPosition) {
        const newPosition = calcPositionOrRandomFromSize({ size: canvasSize });
        particle.position.setTo(newPosition);
        particle.velocity.setTo(particle.initialVelocity);
        particle.absorberOrbit = void 0;
        particle.needsNewPosition = false;
      }
      if (this.options.orbits) {
        if (particle.absorberOrbit === void 0) {
          particle.absorberOrbit = Vector.origin;
          particle.absorberOrbit.length = getDistance(particle.getPosition(), this.position);
          particle.absorberOrbit.angle = getRandom() * maxAngle;
        }
        if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {
          const minSize = Math.min(canvasSize.width, canvasSize.height), offset = 1, randomOffset = 0.1, randomFactor = 0.2;
          particle.absorberOrbit.length = minSize * (offset + (getRandom() * randomFactor - randomOffset));
        }
        if (particle.absorberOrbitDirection === void 0) {
          particle.absorberOrbitDirection = particle.velocity.x >= minVelocity ? RotateDirection.clockwise : RotateDirection.counterClockwise;
        }
        const orbitRadius = particle.absorberOrbit.length, orbitAngle = particle.absorberOrbit.angle, orbitDirection = particle.absorberOrbitDirection;
        particle.velocity.setTo(Vector.origin);
        const updateFunc = {
          x: orbitDirection === RotateDirection.clockwise ? Math.cos : Math.sin,
          y: orbitDirection === RotateDirection.clockwise ? Math.sin : Math.cos
        };
        particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);
        particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);
        particle.absorberOrbit.length -= v.length;
        particle.absorberOrbit.angle += (particle.retina.moveSpeed ?? minVelocity) * container2.retina.pixelRatio / percentDenominator * container2.retina.reduceFactor;
      } else {
        const addV = Vector.origin;
        addV.length = v.length;
        addV.angle = v.angle;
        particle.velocity.addTo(addV);
      }
    };
    this._absorbers = absorbers;
    this._container = container;
    this._engine = engine;
    this.initialPosition = position ? Vector.create(position.x, position.y) : void 0;
    if (options instanceof Absorber) {
      this.options = options;
    } else {
      this.options = new Absorber();
      this.options.load(options);
    }
    this.dragging = false;
    this.name = this.options.name;
    this.opacity = this.options.opacity;
    this.size = getRangeValue(this.options.size.value) * container.retina.pixelRatio;
    this.mass = this.size * this.options.size.density * container.retina.reduceFactor;
    const limit = this.options.size.limit;
    this.limit = {
      radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,
      mass: limit.mass
    };
    this.color = rangeColorToRgb(this._engine, this.options.color) ?? {
      b: 0,
      g: 0,
      r: 0
    };
    this.position = this.initialPosition?.copy() ?? this._calcPosition();
  }
  attract(particle) {
    const container = this._container, options = this.options;
    if (options.draggable) {
      const mouse = container.interactivity.mouse;
      if (mouse.clicking && mouse.downPosition) {
        const mouseDist = getDistance(this.position, mouse.downPosition);
        if (mouseDist <= this.size) {
          this.dragging = true;
        }
      } else {
        this.dragging = false;
      }
      if (this.dragging && mouse.position) {
        this.position.x = mouse.position.x;
        this.position.y = mouse.position.y;
      }
    }
    const pos = particle.getPosition(), { dx, dy, distance } = getDistances(this.position, pos), v = Vector.create(dx, dy);
    v.length = this.mass / Math.pow(distance, squareExp) * container.retina.reduceFactor;
    if (distance < this.size + particle.getRadius()) {
      const sizeFactor = particle.getRadius() * absorbFactor * container.retina.pixelRatio;
      if (this.size > particle.getRadius() && distance < this.size - particle.getRadius() || particle.absorberOrbit !== void 0 && particle.absorberOrbit.length < minOrbitLength) {
        if (options.destroy) {
          particle.destroy();
        } else {
          particle.needsNewPosition = true;
          this._updateParticlePosition(particle, v);
        }
      } else {
        if (options.destroy) {
          particle.size.value -= sizeFactor;
        }
        this._updateParticlePosition(particle, v);
      }
      if (this.limit.radius <= minRadius || this.size < this.limit.radius) {
        this.size += sizeFactor;
      }
      if (this.limit.mass <= minMass || this.mass < this.limit.mass) {
        this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;
      }
    } else {
      this._updateParticlePosition(particle, v);
    }
  }
  draw(context) {
    context.translate(this.position.x, this.position.y);
    context.beginPath();
    context.arc(originPoint.x, originPoint.y, this.size, minAngle, maxAngle, false);
    context.closePath();
    context.fillStyle = getStyleFromRgb(this.color, this.opacity);
    context.fill();
  }
  resize() {
    const initialPosition = this.initialPosition;
    this.position = initialPosition && isPointInside(initialPosition, this._container.canvas.size, Vector.origin) ? initialPosition : this._calcPosition();
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/Absorbers.js
var defaultIndex = 0;
var Absorbers = class {
  constructor(container, engine) {
    this._container = container;
    this._engine = engine;
    this.array = [];
    this.absorbers = [];
    this.interactivityAbsorbers = [];
    container.getAbsorber = (idxOrName) => idxOrName === void 0 || isNumber(idxOrName) ? this.array[idxOrName ?? defaultIndex] : this.array.find((t) => t.name === idxOrName);
    container.addAbsorber = async (options, position) => this.addAbsorber(options, position);
  }
  async addAbsorber(options, position) {
    const absorber = new AbsorberInstance(this, this._container, this._engine, options, position);
    this.array.push(absorber);
    return Promise.resolve(absorber);
  }
  draw(context) {
    for (const absorber of this.array) {
      absorber.draw(context);
    }
  }
  handleClickMode(mode) {
    const absorberOptions = this.absorbers, modeAbsorbers = this.interactivityAbsorbers;
    if (mode === AbsorberClickMode.absorber) {
      const absorbersModeOptions = itemFromSingleOrMultiple(modeAbsorbers), absorbersOptions = absorbersModeOptions ?? itemFromSingleOrMultiple(absorberOptions), aPosition = this._container.interactivity.mouse.clickPosition;
      void this.addAbsorber(absorbersOptions, aPosition);
    }
  }
  async init() {
    this.absorbers = this._container.actualOptions.absorbers;
    this.interactivityAbsorbers = this._container.actualOptions.interactivity.modes.absorbers;
    const promises = executeOnSingleOrMultiple(this.absorbers, async (absorber) => {
      await this.addAbsorber(absorber);
    });
    if (promises instanceof Array) {
      await Promise.all(promises);
    } else {
      await promises;
    }
  }
  particleUpdate(particle) {
    for (const absorber of this.array) {
      absorber.attract(particle);
      if (particle.destroyed) {
        break;
      }
    }
  }
  removeAbsorber(absorber) {
    const index = this.array.indexOf(absorber), deleteCount = 1;
    if (index >= defaultIndex) {
      this.array.splice(index, deleteCount);
    }
  }
  resize() {
    for (const absorber of this.array) {
      absorber.resize();
    }
  }
  stop() {
    this.array = [];
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/AbsorbersPlugin.js
var AbsorbersPlugin = class {
  constructor(engine) {
    this.id = "absorbers";
    this._engine = engine;
  }
  async getPlugin(container) {
    return Promise.resolve(new Absorbers(container, this._engine));
  }
  loadOptions(options, source) {
    if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
      return;
    }
    if (source?.absorbers) {
      options.absorbers = executeOnSingleOrMultiple(source.absorbers, (absorber) => {
        const tmp = new Absorber();
        tmp.load(absorber);
        return tmp;
      });
    }
    options.interactivity.modes.absorbers = executeOnSingleOrMultiple(source?.interactivity?.modes?.absorbers, (absorber) => {
      const tmp = new Absorber();
      tmp.load(absorber);
      return tmp;
    });
  }
  needsPlugin(options) {
    if (!options) {
      return false;
    }
    const absorbers = options.absorbers;
    if (isArray(absorbers)) {
      return !!absorbers.length;
    } else if (absorbers) {
      return true;
    } else if (options.interactivity?.events?.onClick?.mode && isInArray(AbsorberClickMode.absorber, options.interactivity.events.onClick.mode)) {
      return true;
    }
    return false;
  }
};

// node_modules/@tsparticles/plugin-absorbers/browser/index.js
async function loadAbsorbersPlugin(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addPlugin(new AbsorbersPlugin(engine), refresh);
}

// node_modules/@tsparticles/updater-destroy/browser/Options/Classes/DestroyBounds.js
var DestroyBounds = class {
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.bottom !== void 0) {
      this.bottom = setRangeValue(data.bottom);
    }
    if (data.left !== void 0) {
      this.left = setRangeValue(data.left);
    }
    if (data.right !== void 0) {
      this.right = setRangeValue(data.right);
    }
    if (data.top !== void 0) {
      this.top = setRangeValue(data.top);
    }
  }
};

// node_modules/@tsparticles/updater-destroy/browser/Enums/DestroyMode.js
var DestroyMode;
(function(DestroyMode2) {
  DestroyMode2["none"] = "none";
  DestroyMode2["split"] = "split";
})(DestroyMode || (DestroyMode = {}));

// node_modules/@tsparticles/updater-destroy/browser/Options/Classes/SplitFactor.js
var SplitFactor = class extends ValueWithRandom {
  constructor() {
    super();
    this.value = 3;
  }
};

// node_modules/@tsparticles/updater-destroy/browser/Options/Classes/SplitRate.js
var SplitRate = class extends ValueWithRandom {
  constructor() {
    super();
    this.value = { min: 4, max: 9 };
  }
};

// node_modules/@tsparticles/updater-destroy/browser/Options/Classes/Split.js
var Split = class {
  constructor() {
    this.count = 1;
    this.factor = new SplitFactor();
    this.rate = new SplitRate();
    this.sizeOffset = true;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.color !== void 0) {
      this.color = OptionsColor.create(this.color, data.color);
    }
    if (data.count !== void 0) {
      this.count = data.count;
    }
    this.factor.load(data.factor);
    this.rate.load(data.rate);
    this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {
      return deepExtend({}, particles);
    });
    if (data.sizeOffset !== void 0) {
      this.sizeOffset = data.sizeOffset;
    }
    if (data.colorOffset) {
      this.colorOffset = this.colorOffset ?? {};
      if (data.colorOffset.h !== void 0) {
        this.colorOffset.h = data.colorOffset.h;
      }
      if (data.colorOffset.s !== void 0) {
        this.colorOffset.s = data.colorOffset.s;
      }
      if (data.colorOffset.l !== void 0) {
        this.colorOffset.l = data.colorOffset.l;
      }
    }
  }
};

// node_modules/@tsparticles/updater-destroy/browser/Options/Classes/Destroy.js
var Destroy = class {
  constructor() {
    this.bounds = new DestroyBounds();
    this.mode = DestroyMode.none;
    this.split = new Split();
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.mode) {
      this.mode = data.mode;
    }
    if (data.bounds) {
      this.bounds.load(data.bounds);
    }
    this.split.load(data.split);
  }
};

// node_modules/@tsparticles/updater-destroy/browser/Utils.js
var defaultOffset = 0;
var minDestroySize = 0.5;
var defaultSplitCount = 0;
var increment = 1;
var unbreakableTime = 500;
var minSplitCount = 0;
function addSplitParticle(engine, container, parent, splitParticlesOptions) {
  const destroyOptions = parent.options.destroy;
  if (!destroyOptions) {
    return;
  }
  const splitOptions = destroyOptions.split, options = loadParticlesOptions(engine, container, parent.options), factor = getRangeValue(splitOptions.factor.value), parentColor = parent.getFillColor();
  if (splitOptions.color) {
    options.color.load(splitOptions.color);
  } else if (splitOptions.colorOffset && parentColor) {
    options.color.load({
      value: {
        hsl: {
          h: parentColor.h + getRangeValue(splitOptions.colorOffset.h ?? defaultOffset),
          s: parentColor.s + getRangeValue(splitOptions.colorOffset.s ?? defaultOffset),
          l: parentColor.l + getRangeValue(splitOptions.colorOffset.l ?? defaultOffset)
        }
      }
    });
  } else {
    options.color.load({
      value: {
        hsl: parent.getFillColor()
      }
    });
  }
  options.move.load({
    center: {
      x: parent.position.x,
      y: parent.position.y,
      mode: PixelMode.precise
    }
  });
  if (isNumber(options.size.value)) {
    options.size.value /= factor;
  } else {
    options.size.value.min /= factor;
    options.size.value.max /= factor;
  }
  options.load(splitParticlesOptions);
  const offset = splitOptions.sizeOffset ? setRangeValue(-parent.size.value, parent.size.value) : defaultOffset, position = {
    x: parent.position.x + randomInRange(offset),
    y: parent.position.y + randomInRange(offset)
  };
  return container.particles.addParticle(position, options, parent.group, (particle) => {
    if (particle.size.value < minDestroySize) {
      return false;
    }
    particle.velocity.length = randomInRange(setRangeValue(parent.velocity.length, particle.velocity.length));
    particle.splitCount = (parent.splitCount ?? defaultSplitCount) + increment;
    particle.unbreakable = true;
    setTimeout(() => {
      particle.unbreakable = false;
    }, unbreakableTime);
    return true;
  });
}
function split(engine, container, particle) {
  const destroyOptions = particle.options.destroy;
  if (!destroyOptions) {
    return;
  }
  const splitOptions = destroyOptions.split;
  if (splitOptions.count >= minSplitCount && (particle.splitCount === void 0 || particle.splitCount++ > splitOptions.count)) {
    return;
  }
  const rate = getRangeValue(splitOptions.rate.value), particlesSplitOptions = itemFromSingleOrMultiple(splitOptions.particles);
  for (let i = 0; i < rate; i++) {
    addSplitParticle(engine, container, particle, particlesSplitOptions);
  }
}

// node_modules/@tsparticles/updater-destroy/browser/DestroyUpdater.js
var DestroyUpdater = class {
  constructor(engine, container) {
    this.container = container;
    this.engine = engine;
  }
  init(particle) {
    const container = this.container, particlesOptions = particle.options, destroyOptions = particlesOptions.destroy;
    if (!destroyOptions) {
      return;
    }
    particle.splitCount = 0;
    const destroyBoundsOptions = destroyOptions.bounds;
    if (!particle.destroyBounds) {
      particle.destroyBounds = {};
    }
    const { bottom, left, right, top } = destroyBoundsOptions, { destroyBounds } = particle, canvasSize = container.canvas.size;
    if (bottom) {
      destroyBounds.bottom = getRangeValue(bottom) * canvasSize.height / percentDenominator;
    }
    if (left) {
      destroyBounds.left = getRangeValue(left) * canvasSize.width / percentDenominator;
    }
    if (right) {
      destroyBounds.right = getRangeValue(right) * canvasSize.width / percentDenominator;
    }
    if (top) {
      destroyBounds.top = getRangeValue(top) * canvasSize.height / percentDenominator;
    }
  }
  isEnabled(particle) {
    return !particle.destroyed;
  }
  loadOptions(options, ...sources) {
    if (!options.destroy) {
      options.destroy = new Destroy();
    }
    for (const source of sources) {
      options.destroy.load(source?.destroy);
    }
  }
  particleDestroyed(particle, override) {
    if (override) {
      return;
    }
    const destroyOptions = particle.options.destroy;
    if (destroyOptions && destroyOptions.mode === DestroyMode.split) {
      split(this.engine, this.container, particle);
    }
  }
  update(particle) {
    if (!this.isEnabled(particle)) {
      return;
    }
    const position = particle.getPosition(), bounds = particle.destroyBounds;
    if (!bounds) {
      return;
    }
    if (bounds.bottom !== void 0 && position.y >= bounds.bottom || bounds.left !== void 0 && position.x <= bounds.left || bounds.right !== void 0 && position.x >= bounds.right || bounds.top !== void 0 && position.y <= bounds.top) {
      particle.destroy();
    }
  }
};

// node_modules/@tsparticles/updater-destroy/browser/index.js
async function loadDestroyUpdater(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addParticleUpdater("destroy", (container) => {
    return Promise.resolve(new DestroyUpdater(engine, container));
  }, refresh);
}

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/EmitterLife.js
var EmitterLife = class {
  constructor() {
    this.wait = false;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.count !== void 0) {
      this.count = data.count;
    }
    if (data.delay !== void 0) {
      this.delay = setRangeValue(data.delay);
    }
    if (data.duration !== void 0) {
      this.duration = setRangeValue(data.duration);
    }
    if (data.wait !== void 0) {
      this.wait = data.wait;
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/EmitterRate.js
var EmitterRate = class {
  constructor() {
    this.quantity = 1;
    this.delay = 0.1;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.quantity !== void 0) {
      this.quantity = setRangeValue(data.quantity);
    }
    if (data.delay !== void 0) {
      this.delay = setRangeValue(data.delay);
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/EmitterShapeReplace.js
var EmitterShapeReplace = class {
  constructor() {
    this.color = false;
    this.opacity = false;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.color !== void 0) {
      this.color = data.color;
    }
    if (data.opacity !== void 0) {
      this.opacity = data.opacity;
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/EmitterShape.js
var EmitterShape = class {
  constructor() {
    this.options = {};
    this.replace = new EmitterShapeReplace();
    this.type = "square";
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.options !== void 0) {
      this.options = deepExtend({}, data.options ?? {});
    }
    this.replace.load(data.replace);
    if (data.type !== void 0) {
      this.type = data.type;
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/EmitterSize.js
var EmitterSize = class {
  constructor() {
    this.mode = PixelMode.percent;
    this.height = 0;
    this.width = 0;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.mode !== void 0) {
      this.mode = data.mode;
    }
    if (data.height !== void 0) {
      this.height = data.height;
    }
    if (data.width !== void 0) {
      this.width = data.width;
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Options/Classes/Emitter.js
var Emitter = class {
  constructor() {
    this.autoPlay = true;
    this.fill = true;
    this.life = new EmitterLife();
    this.rate = new EmitterRate();
    this.shape = new EmitterShape();
    this.startCount = 0;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.autoPlay !== void 0) {
      this.autoPlay = data.autoPlay;
    }
    if (data.size !== void 0) {
      if (!this.size) {
        this.size = new EmitterSize();
      }
      this.size.load(data.size);
    }
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    this.domId = data.domId;
    if (data.fill !== void 0) {
      this.fill = data.fill;
    }
    this.life.load(data.life);
    this.name = data.name;
    this.particles = executeOnSingleOrMultiple(data.particles, (particles) => {
      return deepExtend({}, particles);
    });
    this.rate.load(data.rate);
    this.shape.load(data.shape);
    if (data.position !== void 0) {
      this.position = {};
      if (data.position.x !== void 0) {
        this.position.x = setRangeValue(data.position.x);
      }
      if (data.position.y !== void 0) {
        this.position.y = setRangeValue(data.position.y);
      }
    }
    if (data.spawnColor !== void 0) {
      if (this.spawnColor === void 0) {
        this.spawnColor = new AnimatableColor();
      }
      this.spawnColor.load(data.spawnColor);
    }
    if (data.startCount !== void 0) {
      this.startCount = data.startCount;
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Enums/EmitterClickMode.js
var EmitterClickMode;
(function(EmitterClickMode2) {
  EmitterClickMode2["emitter"] = "emitter";
})(EmitterClickMode || (EmitterClickMode = {}));

// node_modules/@tsparticles/plugin-emitters/browser/EmitterInstance.js
var half2 = 0.5;
var defaultLifeDelay = 0;
var minLifeCount = 0;
var defaultSpawnDelay = 0;
var defaultEmitDelay = 0;
var defaultLifeCount = -1;
var defaultColorAnimationFactor = 1;
function setParticlesOptionsColor(particlesOptions, color) {
  if (particlesOptions.color) {
    particlesOptions.color.value = color;
  } else {
    particlesOptions.color = {
      value: color
    };
  }
}
var EmitterInstance = class {
  constructor(engine, emitters, container, options, position) {
    this.emitters = emitters;
    this.container = container;
    this._destroy = () => {
      this._mutationObserver?.disconnect();
      this._mutationObserver = void 0;
      this._resizeObserver?.disconnect();
      this._resizeObserver = void 0;
      this.emitters.removeEmitter(this);
      this._engine.dispatchEvent("emitterDestroyed", {
        container: this.container,
        data: {
          emitter: this
        }
      });
    };
    this._prepareToDie = () => {
      if (this._paused) {
        return;
      }
      const duration = this.options.life?.duration !== void 0 ? getRangeValue(this.options.life.duration) : void 0, minDuration = 0, minLifeCount2 = 0;
      if (this.container.retina.reduceFactor && (this._lifeCount > minLifeCount2 || this._immortal) && duration !== void 0 && duration > minDuration) {
        this._duration = duration * millisecondsToSeconds;
      }
    };
    this._setColorAnimation = (animation, initValue, maxValue, factor = defaultColorAnimationFactor) => {
      const container2 = this.container;
      if (!animation.enable) {
        return initValue;
      }
      const colorOffset = randomInRange(animation.offset), delay = getRangeValue(this.options.rate.delay), emitFactor = delay * millisecondsToSeconds / container2.retina.reduceFactor, defaultColorSpeed = 0, colorSpeed = getRangeValue(animation.speed ?? defaultColorSpeed);
      return (initValue + colorSpeed * container2.fpsLimit / emitFactor + colorOffset * factor) % maxValue;
    };
    this._engine = engine;
    this._currentDuration = 0;
    this._currentEmitDelay = 0;
    this._currentSpawnDelay = 0;
    this._initialPosition = position;
    if (options instanceof Emitter) {
      this.options = options;
    } else {
      this.options = new Emitter();
      this.options.load(options);
    }
    this._spawnDelay = getRangeValue(this.options.life.delay ?? defaultLifeDelay) * millisecondsToSeconds / this.container.retina.reduceFactor;
    this.position = this._initialPosition ?? this._calcPosition();
    this.name = this.options.name;
    this.fill = this.options.fill;
    this._firstSpawn = !this.options.life.wait;
    this._startParticlesAdded = false;
    let particlesOptions = deepExtend({}, this.options.particles);
    particlesOptions ??= {};
    particlesOptions.move ??= {};
    particlesOptions.move.direction ??= this.options.direction;
    if (this.options.spawnColor) {
      this.spawnColor = rangeColorToHsl(this._engine, this.options.spawnColor);
    }
    this._paused = !this.options.autoPlay;
    this._particlesOptions = particlesOptions;
    this._size = this._calcSize();
    this.size = getSize(this._size, this.container.canvas.size);
    this._lifeCount = this.options.life.count ?? defaultLifeCount;
    this._immortal = this._lifeCount <= minLifeCount;
    if (this.options.domId) {
      const element = document.getElementById(this.options.domId);
      if (element) {
        this._mutationObserver = new MutationObserver(() => {
          this.resize();
        });
        this._resizeObserver = new ResizeObserver(() => {
          this.resize();
        });
        this._mutationObserver.observe(element, {
          attributes: true,
          attributeFilter: ["style", "width", "height"]
        });
        this._resizeObserver.observe(element);
      }
    }
    const shapeOptions = this.options.shape, shapeGenerator = this._engine.emitterShapeManager?.getShapeGenerator(shapeOptions.type);
    if (shapeGenerator) {
      this._shape = shapeGenerator.generate(this.position, this.size, this.fill, shapeOptions.options);
    }
    this._engine.dispatchEvent("emitterCreated", {
      container,
      data: {
        emitter: this
      }
    });
    this.play();
  }
  externalPause() {
    this._paused = true;
    this.pause();
  }
  externalPlay() {
    this._paused = false;
    this.play();
  }
  async init() {
    await this._shape?.init();
  }
  pause() {
    if (this._paused) {
      return;
    }
    delete this._emitDelay;
  }
  play() {
    if (this._paused) {
      return;
    }
    if (!(this.container.retina.reduceFactor && (this._lifeCount > minLifeCount || this._immortal || !this.options.life.count) && (this._firstSpawn || this._currentSpawnDelay >= (this._spawnDelay ?? defaultSpawnDelay)))) {
      return;
    }
    if (this._emitDelay === void 0) {
      const delay = getRangeValue(this.options.rate.delay);
      this._emitDelay = delay * millisecondsToSeconds / this.container.retina.reduceFactor;
    }
    if (this._lifeCount > minLifeCount || this._immortal) {
      this._prepareToDie();
    }
  }
  resize() {
    const initialPosition = this._initialPosition;
    this.position = initialPosition && isPointInside(initialPosition, this.container.canvas.size, Vector.origin) ? initialPosition : this._calcPosition();
    this._size = this._calcSize();
    this.size = getSize(this._size, this.container.canvas.size);
    this._shape?.resize(this.position, this.size);
  }
  update(delta) {
    if (this._paused) {
      return;
    }
    if (this._firstSpawn) {
      this._firstSpawn = false;
      this._currentSpawnDelay = this._spawnDelay ?? defaultSpawnDelay;
      this._currentEmitDelay = this._emitDelay ?? defaultEmitDelay;
    }
    if (!this._startParticlesAdded) {
      this._startParticlesAdded = true;
      this._emitParticles(this.options.startCount);
    }
    if (this._duration !== void 0) {
      this._currentDuration += delta.value;
      if (this._currentDuration >= this._duration) {
        this.pause();
        if (this._spawnDelay !== void 0) {
          delete this._spawnDelay;
        }
        if (!this._immortal) {
          this._lifeCount--;
        }
        if (this._lifeCount > minLifeCount || this._immortal) {
          this.position = this._calcPosition();
          this._shape?.resize(this.position, this.size);
          this._spawnDelay = getRangeValue(this.options.life.delay ?? defaultLifeDelay) * millisecondsToSeconds / this.container.retina.reduceFactor;
        } else {
          this._destroy();
        }
        this._currentDuration -= this._duration;
        delete this._duration;
      }
    }
    if (this._spawnDelay !== void 0) {
      this._currentSpawnDelay += delta.value;
      if (this._currentSpawnDelay >= this._spawnDelay) {
        this._engine.dispatchEvent("emitterPlay", {
          container: this.container
        });
        this.play();
        this._currentSpawnDelay -= this._currentSpawnDelay;
        delete this._spawnDelay;
      }
    }
    if (this._emitDelay !== void 0) {
      this._currentEmitDelay += delta.value;
      if (this._currentEmitDelay >= this._emitDelay) {
        this._emit();
        this._currentEmitDelay -= this._emitDelay;
      }
    }
  }
  _calcPosition() {
    if (this.options.domId) {
      const element = document.getElementById(this.options.domId);
      if (element) {
        const elRect = element.getBoundingClientRect(), pxRatio = this.container.retina.pixelRatio;
        return {
          x: (elRect.x + elRect.width * half2) * pxRatio,
          y: (elRect.y + elRect.height * half2) * pxRatio
        };
      }
    }
    return calcPositionOrRandomFromSizeRanged({
      size: this.container.canvas.size,
      position: this.options.position
    });
  }
  _calcSize() {
    const container = this.container;
    if (this.options.domId) {
      const element = document.getElementById(this.options.domId);
      if (element) {
        const elRect = element.getBoundingClientRect();
        return {
          width: elRect.width * container.retina.pixelRatio,
          height: elRect.height * container.retina.pixelRatio,
          mode: PixelMode.precise
        };
      }
    }
    return this.options.size ?? (() => {
      const size = new EmitterSize();
      size.load({
        height: 0,
        mode: PixelMode.percent,
        width: 0
      });
      return size;
    })();
  }
  _emit() {
    if (this._paused) {
      return;
    }
    const quantity = getRangeValue(this.options.rate.quantity);
    this._emitParticles(quantity);
  }
  _emitParticles(quantity) {
    const singleParticlesOptions = itemFromSingleOrMultiple(this._particlesOptions);
    for (let i = 0; i < quantity; i++) {
      const particlesOptions = deepExtend({}, singleParticlesOptions);
      if (this.spawnColor) {
        const hslAnimation = this.options.spawnColor?.animation;
        if (hslAnimation) {
          const maxValues = {
            h: 360,
            s: 100,
            l: 100
          }, colorFactor = 3.6;
          this.spawnColor.h = this._setColorAnimation(hslAnimation.h, this.spawnColor.h, maxValues.h, colorFactor);
          this.spawnColor.s = this._setColorAnimation(hslAnimation.s, this.spawnColor.s, maxValues.s);
          this.spawnColor.l = this._setColorAnimation(hslAnimation.l, this.spawnColor.l, maxValues.l);
        }
        setParticlesOptionsColor(particlesOptions, this.spawnColor);
      }
      const shapeOptions = this.options.shape;
      let position = this.position;
      if (this._shape) {
        const shapePosData = this._shape.randomPosition();
        if (shapePosData) {
          position = shapePosData.position;
          const replaceData = shapeOptions.replace;
          if (replaceData.color && shapePosData.color) {
            setParticlesOptionsColor(particlesOptions, shapePosData.color);
          }
          if (replaceData.opacity) {
            if (particlesOptions.opacity) {
              particlesOptions.opacity.value = shapePosData.opacity;
            } else {
              particlesOptions.opacity = {
                value: shapePosData.opacity
              };
            }
          }
        } else {
          position = null;
        }
      }
      if (position) {
        this.container.particles.addParticle(position, particlesOptions);
      }
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/Emitters.js
var Emitters = class {
  constructor(engine, container) {
    this.container = container;
    this._engine = engine;
    this.array = [];
    this.emitters = [];
    this.interactivityEmitters = {
      random: {
        count: 1,
        enable: false
      },
      value: []
    };
    const defaultIndex2 = 0;
    container.getEmitter = (idxOrName) => idxOrName === void 0 || isNumber(idxOrName) ? this.array[idxOrName ?? defaultIndex2] : this.array.find((t) => t.name === idxOrName);
    container.addEmitter = async (options, position) => this.addEmitter(options, position);
    container.removeEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        this.removeEmitter(emitter);
      }
    };
    container.playEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        emitter.externalPlay();
      }
    };
    container.pauseEmitter = (idxOrName) => {
      const emitter = container.getEmitter(idxOrName);
      if (emitter) {
        emitter.externalPause();
      }
    };
  }
  async addEmitter(options, position) {
    const emitterOptions = new Emitter();
    emitterOptions.load(options);
    const emitter = new EmitterInstance(this._engine, this, this.container, emitterOptions, position);
    await emitter.init();
    this.array.push(emitter);
    return emitter;
  }
  handleClickMode(mode) {
    const emitterOptions = this.emitters, modeEmitters = this.interactivityEmitters;
    if (mode !== EmitterClickMode.emitter) {
      return;
    }
    let emittersModeOptions;
    if (modeEmitters && isArray(modeEmitters.value)) {
      const minLength = 0;
      if (modeEmitters.value.length > minLength && modeEmitters.random.enable) {
        emittersModeOptions = [];
        const usedIndexes = [];
        for (let i = 0; i < modeEmitters.random.count; i++) {
          const idx = arrayRandomIndex(modeEmitters.value);
          if (usedIndexes.includes(idx) && usedIndexes.length < modeEmitters.value.length) {
            i--;
            continue;
          }
          usedIndexes.push(idx);
          emittersModeOptions.push(itemFromArray(modeEmitters.value, idx));
        }
      } else {
        emittersModeOptions = modeEmitters.value;
      }
    } else {
      emittersModeOptions = modeEmitters?.value;
    }
    const emittersOptions = emittersModeOptions ?? emitterOptions, ePosition = this.container.interactivity.mouse.clickPosition;
    void executeOnSingleOrMultiple(emittersOptions, async (emitter) => {
      await this.addEmitter(emitter, ePosition);
    });
  }
  async init() {
    this.emitters = this.container.actualOptions.emitters;
    this.interactivityEmitters = this.container.actualOptions.interactivity.modes.emitters;
    if (!this.emitters) {
      return;
    }
    if (isArray(this.emitters)) {
      for (const emitterOptions of this.emitters) {
        await this.addEmitter(emitterOptions);
      }
    } else {
      await this.addEmitter(this.emitters);
    }
  }
  pause() {
    for (const emitter of this.array) {
      emitter.pause();
    }
  }
  play() {
    for (const emitter of this.array) {
      emitter.play();
    }
  }
  removeEmitter(emitter) {
    const index = this.array.indexOf(emitter), minIndex = 0, deleteCount = 1;
    if (index >= minIndex) {
      this.array.splice(index, deleteCount);
    }
  }
  resize() {
    for (const emitter of this.array) {
      emitter.resize();
    }
  }
  stop() {
    this.array = [];
  }
  update(delta) {
    for (const emitter of this.array) {
      emitter.update(delta);
    }
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/EmittersPlugin.js
var EmittersPlugin = class {
  constructor(engine) {
    this._engine = engine;
    this.id = "emitters";
  }
  getPlugin(container) {
    return Promise.resolve(new Emitters(this._engine, container));
  }
  loadOptions(options, source) {
    if (!this.needsPlugin(options) && !this.needsPlugin(source)) {
      return;
    }
    if (source?.emitters) {
      options.emitters = executeOnSingleOrMultiple(source.emitters, (emitter) => {
        const tmp = new Emitter();
        tmp.load(emitter);
        return tmp;
      });
    }
    const interactivityEmitters = source?.interactivity?.modes?.emitters;
    if (interactivityEmitters) {
      if (isArray(interactivityEmitters)) {
        options.interactivity.modes.emitters = {
          random: {
            count: 1,
            enable: true
          },
          value: interactivityEmitters.map((s) => {
            const tmp = new Emitter();
            tmp.load(s);
            return tmp;
          })
        };
      } else {
        const emitterMode = interactivityEmitters;
        if (emitterMode.value !== void 0) {
          const defaultCount = 1;
          if (isArray(emitterMode.value)) {
            options.interactivity.modes.emitters = {
              random: {
                count: emitterMode.random.count ?? defaultCount,
                enable: emitterMode.random.enable ?? false
              },
              value: emitterMode.value.map((s) => {
                const tmp = new Emitter();
                tmp.load(s);
                return tmp;
              })
            };
          } else {
            const tmp = new Emitter();
            tmp.load(emitterMode.value);
            options.interactivity.modes.emitters = {
              random: {
                count: emitterMode.random.count ?? defaultCount,
                enable: emitterMode.random.enable ?? false
              },
              value: tmp
            };
          }
        } else {
          const emitterOptions = options.interactivity.modes.emitters = {
            random: {
              count: 1,
              enable: false
            },
            value: new Emitter()
          };
          emitterOptions.value.load(interactivityEmitters);
        }
      }
    }
  }
  needsPlugin(options) {
    if (!options) {
      return false;
    }
    const emitters = options.emitters;
    return isArray(emitters) && !!emitters.length || emitters !== void 0 || !!options.interactivity?.events?.onClick?.mode && isInArray(EmitterClickMode.emitter, options.interactivity.events.onClick.mode);
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/ShapeManager.js
var shapeGeneratorss = /* @__PURE__ */ new Map();
var ShapeManager = class {
  constructor(engine) {
    this._engine = engine;
  }
  addShapeGenerator(name, generator) {
    if (!this.getShapeGenerator(name)) {
      shapeGeneratorss.set(name, generator);
    }
  }
  getShapeGenerator(name) {
    return shapeGeneratorss.get(name);
  }
  getSupportedShapeGenerators() {
    return shapeGeneratorss.keys();
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/EmitterShapeBase.js
var EmitterShapeBase = class {
  constructor(position, size, fill, options) {
    this.position = position;
    this.size = size;
    this.fill = fill;
    this.options = options;
  }
  resize(position, size) {
    this.position = position;
    this.size = size;
  }
};

// node_modules/@tsparticles/plugin-emitters/browser/index.js
async function loadEmittersPlugin(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  if (!engine.emitterShapeManager) {
    engine.emitterShapeManager = new ShapeManager(engine);
  }
  if (!engine.addEmitterShapeGenerator) {
    engine.addEmitterShapeGenerator = (name, generator) => {
      engine.emitterShapeManager?.addShapeGenerator(name, generator);
    };
  }
  const plugin = new EmittersPlugin(engine);
  await engine.addPlugin(plugin, refresh);
}

// node_modules/@tsparticles/plugin-emitters-shape-circle/browser/EmittersCircleShape.js
var quarter = 0.25;
var double3 = 2;
var doublePI = Math.PI * double3;
var squareExp2 = 2;
var half3 = 0.5;
var EmittersCircleShape = class extends EmitterShapeBase {
  constructor(position, size, fill, options) {
    super(position, size, fill, options);
  }
  async init() {
  }
  randomPosition() {
    const size = this.size, fill = this.fill, position = this.position, generateTheta = (x, y) => {
      const u = getRandom() * quarter, theta = Math.atan(y / x * Math.tan(doublePI * u)), v = getRandom();
      if (v < quarter) {
        return theta;
      } else if (v < double3 * quarter) {
        return Math.PI - theta;
      } else if (v < double3 * quarter + quarter) {
        return Math.PI + theta;
      } else {
        return -theta;
      }
    }, radius = (x, y, theta) => x * y / Math.sqrt((y * Math.cos(theta)) ** squareExp2 + (x * Math.sin(theta)) ** squareExp2), [a, b] = [size.width * half3, size.height * half3], randomTheta = generateTheta(a, b), maxRadius = radius(a, b, randomTheta), randomRadius = fill ? maxRadius * Math.sqrt(getRandom()) : maxRadius;
    return {
      position: {
        x: position.x + randomRadius * Math.cos(randomTheta),
        y: position.y + randomRadius * Math.sin(randomTheta)
      }
    };
  }
};

// node_modules/@tsparticles/plugin-emitters-shape-circle/browser/EmittersCircleShapeGenerator.js
var EmittersCircleShapeGenerator = class {
  generate(position, size, fill, options) {
    return new EmittersCircleShape(position, size, fill, options);
  }
};

// node_modules/@tsparticles/plugin-emitters-shape-circle/browser/index.js
async function loadEmittersShapeCircle(engine, refresh = true) {
  const emittersEngine = engine;
  emittersEngine.checkVersion("3.8.1");
  emittersEngine.addEmitterShapeGenerator?.("circle", new EmittersCircleShapeGenerator());
  await emittersEngine.refresh(refresh);
}

// node_modules/@tsparticles/plugin-emitters-shape-square/browser/EmittersSquareShape.js
var sides = 4;
var Sides;
(function(Sides2) {
  Sides2[Sides2["TopLeft"] = 0] = "TopLeft";
  Sides2[Sides2["TopRight"] = 1] = "TopRight";
  Sides2[Sides2["BottomRight"] = 2] = "BottomRight";
  Sides2[Sides2["BottomLeft"] = 3] = "BottomLeft";
})(Sides || (Sides = {}));
function randomSquareCoordinate(position, offset) {
  return position + offset * (getRandom() - half);
}
var EmittersSquareShape = class extends EmitterShapeBase {
  constructor(position, size, fill, options) {
    super(position, size, fill, options);
  }
  async init() {
  }
  randomPosition() {
    const fill = this.fill, position = this.position, size = this.size;
    if (fill) {
      return {
        position: {
          x: randomSquareCoordinate(position.x, size.width),
          y: randomSquareCoordinate(position.y, size.height)
        }
      };
    } else {
      const halfW = size.width * half, halfH = size.height * half, side = Math.floor(getRandom() * sides), v = (getRandom() - half) * double;
      switch (side) {
        case Sides.TopLeft:
          return {
            position: {
              x: position.x + v * halfW,
              y: position.y - halfH
            }
          };
        case Sides.TopRight:
          return {
            position: {
              x: position.x - halfW,
              y: position.y + v * halfH
            }
          };
        case Sides.BottomRight:
          return {
            position: {
              x: position.x + v * halfW,
              y: position.y + halfH
            }
          };
        case Sides.BottomLeft:
        default:
          return {
            position: {
              x: position.x + halfW,
              y: position.y + v * halfH
            }
          };
      }
    }
  }
};

// node_modules/@tsparticles/plugin-emitters-shape-square/browser/EmittersSquareShapeGenerator.js
var EmittersSquareShapeGenerator = class {
  generate(position, size, fill, options) {
    return new EmittersSquareShape(position, size, fill, options);
  }
};

// node_modules/@tsparticles/plugin-emitters-shape-square/browser/index.js
async function loadEmittersShapeSquare(engine, refresh = true) {
  const emittersEngine = engine;
  emittersEngine.checkVersion("3.8.1");
  emittersEngine.addEmitterShapeGenerator?.("square", new EmittersSquareShapeGenerator());
  await emittersEngine.refresh(refresh);
}

// node_modules/@tsparticles/interaction-external-trail/browser/Options/Classes/Trail.js
var Trail = class {
  constructor() {
    this.delay = 1;
    this.pauseOnStop = false;
    this.quantity = 1;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.delay !== void 0) {
      this.delay = data.delay;
    }
    if (data.quantity !== void 0) {
      this.quantity = data.quantity;
    }
    if (data.particles !== void 0) {
      this.particles = deepExtend({}, data.particles);
    }
    if (data.pauseOnStop !== void 0) {
      this.pauseOnStop = data.pauseOnStop;
    }
  }
};

// node_modules/@tsparticles/interaction-external-trail/browser/TrailMaker.js
var trailMode = "trail";
var TrailMaker = class extends ExternalInteractorBase {
  constructor(container) {
    super(container);
    this._delay = 0;
  }
  clear() {
  }
  init() {
  }
  interact(delta) {
    const container = this.container, { interactivity } = container;
    if (!container.retina.reduceFactor) {
      return;
    }
    const options = container.actualOptions, trailOptions = options.interactivity.modes.trail;
    if (!trailOptions) {
      return;
    }
    const optDelay = trailOptions.delay * millisecondsToSeconds / this.container.retina.reduceFactor;
    if (this._delay < optDelay) {
      this._delay += delta.value;
    }
    if (this._delay < optDelay) {
      return;
    }
    const canEmit = !(trailOptions.pauseOnStop && (interactivity.mouse.position === this._lastPosition || interactivity.mouse.position?.x === this._lastPosition?.x && interactivity.mouse.position?.y === this._lastPosition?.y));
    const mousePos = container.interactivity.mouse.position;
    if (mousePos) {
      this._lastPosition = { ...mousePos };
    } else {
      delete this._lastPosition;
    }
    if (canEmit) {
      container.particles.push(trailOptions.quantity, container.interactivity.mouse, trailOptions.particles);
    }
    this._delay -= optDelay;
  }
  isEnabled(particle) {
    const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = (particle?.interactivity ?? options.interactivity).events;
    return mouse.clicking && mouse.inside && !!mouse.position && isInArray(trailMode, events.onClick.mode) || mouse.inside && !!mouse.position && isInArray(trailMode, events.onHover.mode);
  }
  loadModeOptions(options, ...sources) {
    if (!options.trail) {
      options.trail = new Trail();
    }
    for (const source of sources) {
      options.trail.load(source?.trail);
    }
  }
  reset() {
  }
};

// node_modules/@tsparticles/interaction-external-trail/browser/index.js
async function loadExternalTrailInteraction(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addInteractor("externalTrail", (container) => {
    return Promise.resolve(new TrailMaker(container));
  }, refresh);
}

// node_modules/@tsparticles/updater-roll/browser/RollMode.js
var RollMode;
(function(RollMode2) {
  RollMode2["both"] = "both";
  RollMode2["horizontal"] = "horizontal";
  RollMode2["vertical"] = "vertical";
})(RollMode || (RollMode = {}));

// node_modules/@tsparticles/updater-roll/browser/Utils.js
var double4 = 2;
var doublePI2 = Math.PI * double4;
var maxAngle2 = 360;
function initParticle(engine, particle) {
  const rollOpt = particle.options.roll;
  if (!rollOpt?.enable) {
    particle.roll = {
      enable: false,
      horizontal: false,
      vertical: false,
      angle: 0,
      speed: 0
    };
    return;
  }
  particle.roll = {
    enable: rollOpt.enable,
    horizontal: rollOpt.mode === RollMode.horizontal || rollOpt.mode === RollMode.both,
    vertical: rollOpt.mode === RollMode.vertical || rollOpt.mode === RollMode.both,
    angle: getRandom() * doublePI2,
    speed: getRangeValue(rollOpt.speed) / maxAngle2
  };
  if (rollOpt.backColor) {
    particle.backColor = rangeColorToHsl(engine, rollOpt.backColor);
  } else if (rollOpt.darken.enable && rollOpt.enlighten.enable) {
    const alterType = getRandom() >= half ? AlterType.darken : AlterType.enlighten;
    particle.roll.alter = {
      type: alterType,
      value: getRangeValue(alterType === AlterType.darken ? rollOpt.darken.value : rollOpt.enlighten.value)
    };
  } else if (rollOpt.darken.enable) {
    particle.roll.alter = {
      type: AlterType.darken,
      value: getRangeValue(rollOpt.darken.value)
    };
  } else if (rollOpt.enlighten.enable) {
    particle.roll.alter = {
      type: AlterType.enlighten,
      value: getRangeValue(rollOpt.enlighten.value)
    };
  }
}
function updateRoll(particle, delta) {
  const roll = particle.options.roll, data = particle.roll;
  if (!data || !roll?.enable) {
    return;
  }
  const speed = data.speed * delta.factor, max = doublePI2;
  data.angle += speed;
  if (data.angle > max) {
    data.angle -= max;
  }
}

// node_modules/@tsparticles/updater-roll/browser/Options/Classes/RollLight.js
var RollLight = class {
  constructor() {
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.value !== void 0) {
      this.value = setRangeValue(data.value);
    }
  }
};

// node_modules/@tsparticles/updater-roll/browser/Options/Classes/Roll.js
var Roll = class {
  constructor() {
    this.darken = new RollLight();
    this.enable = false;
    this.enlighten = new RollLight();
    this.mode = RollMode.vertical;
    this.speed = 25;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.backColor !== void 0) {
      this.backColor = OptionsColor.create(this.backColor, data.backColor);
    }
    this.darken.load(data.darken);
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    this.enlighten.load(data.enlighten);
    if (data.mode !== void 0) {
      this.mode = data.mode;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
  }
};

// node_modules/@tsparticles/updater-roll/browser/RollUpdater.js
var RollUpdater = class {
  constructor(engine) {
    this._engine = engine;
  }
  getTransformValues(particle) {
    const roll = particle.roll?.enable && particle.roll, rollHorizontal = roll && roll.horizontal, rollVertical = roll && roll.vertical;
    return {
      a: rollHorizontal ? Math.cos(roll.angle) : void 0,
      d: rollVertical ? Math.sin(roll.angle) : void 0
    };
  }
  init(particle) {
    initParticle(this._engine, particle);
  }
  isEnabled(particle) {
    const roll = particle.options.roll;
    return !particle.destroyed && !particle.spawning && !!roll?.enable;
  }
  loadOptions(options, ...sources) {
    if (!options.roll) {
      options.roll = new Roll();
    }
    for (const source of sources) {
      options.roll.load(source?.roll);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateRoll(particle, delta);
  }
};

// node_modules/@tsparticles/updater-roll/browser/index.js
async function loadRollUpdater(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addParticleUpdater("roll", () => {
    return Promise.resolve(new RollUpdater(engine));
  }, refresh);
}

// node_modules/@tsparticles/shape-text/browser/Utils.js
var double5 = 2;
var half4 = 0.5;
function drawText(data) {
  const { context, particle, radius, opacity } = data, character = particle.shapeData;
  if (!character) {
    return;
  }
  const textData = character.value;
  if (textData === void 0) {
    return;
  }
  if (particle.text === void 0) {
    particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);
  }
  const text = particle.text, style = character.style ?? "", weight = character.weight ?? "400", size = Math.round(radius) * double5, font = character.font ?? "Verdana", fill = particle.shapeFill;
  const lines = text?.split("\n");
  if (!lines) {
    return;
  }
  context.font = `${style} ${weight} ${size}px "${font}"`;
  context.globalAlpha = opacity;
  for (let i = 0; i < lines.length; i++) {
    drawLine(context, lines[i], radius, opacity, i, fill);
  }
  context.globalAlpha = 1;
}
function drawLine(context, line, radius, opacity, index, fill) {
  const offsetX = line.length * radius * half4, pos = {
    x: -offsetX,
    y: radius * half4
  }, diameter = radius * double5;
  if (fill) {
    context.fillText(line, pos.x, pos.y + diameter * index);
  } else {
    context.strokeText(line, pos.x, pos.y + diameter * index);
  }
}

// node_modules/@tsparticles/shape-text/browser/TextDrawer.js
var TextDrawer = class {
  constructor() {
    this.validTypes = ["text", "character", "char", "multiline-text"];
  }
  draw(data) {
    drawText(data);
  }
  async init(container) {
    const options = container.actualOptions, { validTypes } = this;
    if (validTypes.find((t) => isInArray(t, options.particles.shape.type))) {
      const shapeOptions = validTypes.map((t) => options.particles.shape.options[t]).find((t) => !!t), promises = [];
      executeOnSingleOrMultiple(shapeOptions, (shape) => {
        promises.push(loadFont(shape.font, shape.weight));
      });
      await Promise.all(promises);
    }
  }
  particleInit(container, particle) {
    if (!particle.shape || !this.validTypes.includes(particle.shape)) {
      return;
    }
    const character = particle.shapeData;
    if (character === void 0) {
      return;
    }
    const textData = character.value;
    if (textData === void 0) {
      return;
    }
    particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);
  }
};

// node_modules/@tsparticles/shape-text/browser/index.js
async function loadTextShape(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addShape(new TextDrawer(), refresh);
}

// node_modules/@tsparticles/updater-tilt/browser/TiltDirection.js
var TiltDirection;
(function(TiltDirection2) {
  TiltDirection2["clockwise"] = "clockwise";
  TiltDirection2["counterClockwise"] = "counter-clockwise";
  TiltDirection2["random"] = "random";
})(TiltDirection || (TiltDirection = {}));

// node_modules/@tsparticles/updater-tilt/browser/Options/Classes/TiltAnimation.js
var TiltAnimation = class {
  constructor() {
    this.enable = false;
    this.speed = 0;
    this.decay = 0;
    this.sync = false;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      this.speed = setRangeValue(data.speed);
    }
    if (data.decay !== void 0) {
      this.decay = setRangeValue(data.decay);
    }
    if (data.sync !== void 0) {
      this.sync = data.sync;
    }
  }
};

// node_modules/@tsparticles/updater-tilt/browser/Options/Classes/Tilt.js
var Tilt = class extends ValueWithRandom {
  constructor() {
    super();
    this.animation = new TiltAnimation();
    this.direction = TiltDirection.clockwise;
    this.enable = false;
    this.value = 0;
  }
  load(data) {
    super.load(data);
    if (isNull(data)) {
      return;
    }
    this.animation.load(data.animation);
    if (data.direction !== void 0) {
      this.direction = data.direction;
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
  }
};

// node_modules/@tsparticles/updater-tilt/browser/TiltUpdater.js
var identity = 1;
var double6 = 2;
var doublePI3 = Math.PI * double6;
var maxAngle3 = 360;
var TiltUpdater = class {
  constructor(container) {
    this.container = container;
  }
  getTransformValues(particle) {
    const tilt = particle.tilt?.enable && particle.tilt;
    return {
      b: tilt ? Math.cos(tilt.value) * tilt.cosDirection : void 0,
      c: tilt ? Math.sin(tilt.value) * tilt.sinDirection : void 0
    };
  }
  init(particle) {
    const tiltOptions = particle.options.tilt;
    if (!tiltOptions) {
      return;
    }
    particle.tilt = {
      enable: tiltOptions.enable,
      value: degToRad(getRangeValue(tiltOptions.value)),
      sinDirection: getRandom() >= half ? identity : -identity,
      cosDirection: getRandom() >= half ? identity : -identity,
      min: 0,
      max: doublePI3
    };
    let tiltDirection = tiltOptions.direction;
    if (tiltDirection === TiltDirection.random) {
      const index = Math.floor(getRandom() * double6), minIndex = 0;
      tiltDirection = index > minIndex ? TiltDirection.counterClockwise : TiltDirection.clockwise;
    }
    switch (tiltDirection) {
      case TiltDirection.counterClockwise:
      case "counterClockwise":
        particle.tilt.status = AnimationStatus.decreasing;
        break;
      case TiltDirection.clockwise:
        particle.tilt.status = AnimationStatus.increasing;
        break;
    }
    const tiltAnimation = particle.options.tilt?.animation;
    if (tiltAnimation?.enable) {
      particle.tilt.decay = identity - getRangeValue(tiltAnimation.decay);
      particle.tilt.velocity = getRangeValue(tiltAnimation.speed) / maxAngle3 * this.container.retina.reduceFactor;
      if (!tiltAnimation.sync) {
        particle.tilt.velocity *= getRandom();
      }
    }
  }
  isEnabled(particle) {
    const tiltAnimation = particle.options.tilt?.animation;
    return !particle.destroyed && !particle.spawning && !!tiltAnimation?.enable;
  }
  loadOptions(options, ...sources) {
    if (!options.tilt) {
      options.tilt = new Tilt();
    }
    for (const source of sources) {
      options.tilt.load(source?.tilt);
    }
  }
  async update(particle, delta) {
    if (!this.isEnabled(particle) || !particle.tilt) {
      return;
    }
    updateAnimation(particle, particle.tilt, false, DestroyType.none, delta);
    await Promise.resolve();
  }
};

// node_modules/@tsparticles/updater-tilt/browser/index.js
async function loadTiltUpdater(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addParticleUpdater("tilt", (container) => {
    return Promise.resolve(new TiltUpdater(container));
  }, refresh);
}

// node_modules/@tsparticles/updater-twinkle/browser/Options/Classes/TwinkleValues.js
var TwinkleValues = class {
  constructor() {
    this.enable = false;
    this.frequency = 0.05;
    this.opacity = 1;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.color !== void 0) {
      this.color = OptionsColor.create(this.color, data.color);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.frequency !== void 0) {
      this.frequency = data.frequency;
    }
    if (data.opacity !== void 0) {
      this.opacity = setRangeValue(data.opacity);
    }
  }
};

// node_modules/@tsparticles/updater-twinkle/browser/Options/Classes/Twinkle.js
var Twinkle = class {
  constructor() {
    this.lines = new TwinkleValues();
    this.particles = new TwinkleValues();
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    this.lines.load(data.lines);
    this.particles.load(data.particles);
  }
};

// node_modules/@tsparticles/updater-twinkle/browser/TwinkleUpdater.js
var TwinkleUpdater = class {
  constructor(engine) {
    this._engine = engine;
  }
  getColorStyles(particle, context, radius, opacity) {
    const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
    if (!twinkleOptions) {
      return {};
    }
    const twinkle = twinkleOptions.particles, twinkling = twinkle.enable && getRandom() < twinkle.frequency, zIndexOptions = particle.options.zIndex, zOffset = 1, zOpacityFactor = (zOffset - particle.zIndexFactor) ** zIndexOptions.opacityRate, twinklingOpacity = twinkling ? getRangeValue(twinkle.opacity) * zOpacityFactor : opacity, twinkleRgb = rangeColorToHsl(this._engine, twinkle.color), twinkleStyle = twinkleRgb ? getStyleFromHsl(twinkleRgb, twinklingOpacity) : void 0, res = {}, needsTwinkle = twinkling && twinkleStyle;
    res.fill = needsTwinkle ? twinkleStyle : void 0;
    res.stroke = needsTwinkle ? twinkleStyle : void 0;
    return res;
  }
  async init() {
    await Promise.resolve();
  }
  isEnabled(particle) {
    const pOptions = particle.options, twinkleOptions = pOptions.twinkle;
    if (!twinkleOptions) {
      return false;
    }
    return twinkleOptions.particles.enable;
  }
  loadOptions(options, ...sources) {
    if (!options.twinkle) {
      options.twinkle = new Twinkle();
    }
    for (const source of sources) {
      options.twinkle.load(source?.twinkle);
    }
  }
  async update() {
    await Promise.resolve();
  }
};

// node_modules/@tsparticles/updater-twinkle/browser/index.js
async function loadTwinkleUpdater(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addParticleUpdater("twinkle", () => {
    return Promise.resolve(new TwinkleUpdater(engine));
  }, refresh);
}

// node_modules/@tsparticles/updater-wobble/browser/Options/Classes/WobbleSpeed.js
var WobbleSpeed = class {
  constructor() {
    this.angle = 50;
    this.move = 10;
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.angle !== void 0) {
      this.angle = setRangeValue(data.angle);
    }
    if (data.move !== void 0) {
      this.move = setRangeValue(data.move);
    }
  }
};

// node_modules/@tsparticles/updater-wobble/browser/Options/Classes/Wobble.js
var Wobble = class {
  constructor() {
    this.distance = 5;
    this.enable = false;
    this.speed = new WobbleSpeed();
  }
  load(data) {
    if (isNull(data)) {
      return;
    }
    if (data.distance !== void 0) {
      this.distance = setRangeValue(data.distance);
    }
    if (data.enable !== void 0) {
      this.enable = data.enable;
    }
    if (data.speed !== void 0) {
      if (isNumber(data.speed)) {
        this.speed.load({ angle: data.speed });
      } else {
        const rangeSpeed = data.speed;
        if (rangeSpeed.min !== void 0) {
          this.speed.load({ angle: rangeSpeed });
        } else {
          this.speed.load(data.speed);
        }
      }
    }
  }
};

// node_modules/@tsparticles/updater-wobble/browser/Utils.js
var defaultDistance = 0;
var double7 = 2;
var doublePI4 = Math.PI * double7;
var distanceFactor = 60;
function updateWobble(particle, delta) {
  const { wobble: wobbleOptions } = particle.options, { wobble } = particle;
  if (!wobbleOptions?.enable || !wobble) {
    return;
  }
  const angleSpeed = wobble.angleSpeed * delta.factor, moveSpeed = wobble.moveSpeed * delta.factor, distance = moveSpeed * ((particle.retina.wobbleDistance ?? defaultDistance) * delta.factor) / (millisecondsToSeconds / distanceFactor), max = doublePI4, { position } = particle;
  wobble.angle += angleSpeed;
  if (wobble.angle > max) {
    wobble.angle -= max;
  }
  position.x += distance * Math.cos(wobble.angle);
  position.y += distance * Math.abs(Math.sin(wobble.angle));
}

// node_modules/@tsparticles/updater-wobble/browser/WobbleUpdater.js
var double8 = 2;
var doublePI5 = Math.PI * double8;
var maxAngle4 = 360;
var moveSpeedFactor = 10;
var defaultDistance2 = 0;
var WobbleUpdater = class {
  constructor(container) {
    this.container = container;
  }
  init(particle) {
    const wobbleOpt = particle.options.wobble;
    if (wobbleOpt?.enable) {
      particle.wobble = {
        angle: getRandom() * doublePI5,
        angleSpeed: getRangeValue(wobbleOpt.speed.angle) / maxAngle4,
        moveSpeed: getRangeValue(wobbleOpt.speed.move) / moveSpeedFactor
      };
    } else {
      particle.wobble = {
        angle: 0,
        angleSpeed: 0,
        moveSpeed: 0
      };
    }
    particle.retina.wobbleDistance = getRangeValue(wobbleOpt?.distance ?? defaultDistance2) * this.container.retina.pixelRatio;
  }
  isEnabled(particle) {
    return !particle.destroyed && !particle.spawning && !!particle.options.wobble?.enable;
  }
  loadOptions(options, ...sources) {
    if (!options.wobble) {
      options.wobble = new Wobble();
    }
    for (const source of sources) {
      options.wobble.load(source?.wobble);
    }
  }
  update(particle, delta) {
    if (!this.isEnabled(particle)) {
      return;
    }
    updateWobble(particle, delta);
  }
};

// node_modules/@tsparticles/updater-wobble/browser/index.js
async function loadWobbleUpdater(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await engine.addParticleUpdater("wobble", (container) => {
    return Promise.resolve(new WobbleUpdater(container));
  }, refresh);
}

// node_modules/tsparticles/browser/index.js
async function loadFull(engine, refresh = true) {
  engine.checkVersion("3.8.1");
  await loadDestroyUpdater(engine, false);
  await loadRollUpdater(engine, false);
  await loadTiltUpdater(engine, false);
  await loadTwinkleUpdater(engine, false);
  await loadWobbleUpdater(engine, false);
  await loadTextShape(engine, false);
  await loadExternalTrailInteraction(engine, false);
  await loadAbsorbersPlugin(engine, false);
  await loadEmittersPlugin(engine, false);
  await loadEmittersShapeCircle(engine, false);
  await loadEmittersShapeSquare(engine, false);
  await loadSlim(engine, refresh);
}
export {
  loadFull
};
//# sourceMappingURL=tsparticles.js.map
